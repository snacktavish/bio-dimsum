// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CONFIG_FILE_HXX
#define CONFIG_FILE_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;
/*
  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;
*/
  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class edgeType;
class fileType;
class treeType;
class locType;
class xyType;
class intlist;
class pType;
class data;
class distribution;
class simulation;
class latitude;
class longitude;
class edges;
class initialpopulation;
class output;
class node;
class visual;
class treestructure;
class locations;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class edgeType: public ::xml_schema::string
{
  public:
  enum value
  {
    impenetrable,
    deadly
  };

  edgeType (value v);

  edgeType (const char* v);

  edgeType (const ::std::string& v);

  edgeType (const ::xml_schema::string& v);

  edgeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  edgeType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  edgeType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  edgeType (const edgeType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual edgeType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  edgeType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_edgeType_convert ();
  }

  protected:
  value
  _xsd_edgeType_convert () const;

  public:
  static const char* const _xsd_edgeType_literals_[2];
  static const value _xsd_edgeType_indexes_[2];
};

class fileType: public ::xml_schema::string
{
  public:
  enum value
  {
    image,
    file
  };

  fileType (value v);

  fileType (const char* v);

  fileType (const ::std::string& v);

  fileType (const ::xml_schema::string& v);

  fileType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  fileType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  fileType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  fileType (const fileType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual fileType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  fileType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_fileType_convert ();
  }

  protected:
  value
  _xsd_fileType_convert () const;

  public:
  static const char* const _xsd_fileType_literals_[2];
  static const value _xsd_fileType_indexes_[2];
};

class treeType: public ::xml_schema::string
{
  public:
  enum value
  {
    parent,
    distance
  };

  treeType (value v);

  treeType (const char* v);

  treeType (const ::std::string& v);

  treeType (const ::xml_schema::string& v);

  treeType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  treeType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  treeType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  treeType (const treeType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual treeType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  treeType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_treeType_convert ();
  }

  protected:
  value
  _xsd_treeType_convert () const;

  public:
  static const char* const _xsd_treeType_literals_[2];
  static const value _xsd_treeType_indexes_[2];
};

class locType: public ::xml_schema::string
{
  public:
  enum value
  {
    all,
    last
  };

  locType (value v);

  locType (const char* v);

  locType (const ::std::string& v);

  locType (const ::xml_schema::string& v);

  locType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  locType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  locType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  locType (const locType& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual locType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  locType&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_locType_convert ();
  }

  protected:
  value
  _xsd_locType_convert () const;

  public:
  static const char* const _xsd_locType_literals_[2];
  static const value _xsd_locType_indexes_[2];
};

class xyType: public ::xml_schema::type
{
  public:
  // data
  // 
  typedef ::data data_type;
  typedef ::xsd::cxx::tree::sequence< data_type > data_sequence;
  typedef data_sequence::iterator data_iterator;
  typedef data_sequence::const_iterator data_const_iterator;
  typedef ::xsd::cxx::tree::traits< data_type, char > data_traits;

  const data_sequence&
  data () const;

  data_sequence&
  data ();

  void
  data (const data_sequence& s);

  // Constructors.
  //
  xyType ();

  xyType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  xyType (const xyType& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual xyType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~xyType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  data_sequence data_;
};

class intlist: public ::xml_schema::simple_type,
  public ::xsd::cxx::tree::list< ::xml_schema::float_, char >
{
  public:
  intlist ();

  intlist (size_type n, const ::xml_schema::float_& x);

  template < typename I >
  intlist (const I& begin, const I& end)
  : ::xsd::cxx::tree::list< ::xml_schema::float_, char > (begin, end, this)
  {
  }

  intlist (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  intlist (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  intlist (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  intlist (const intlist& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual intlist*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~intlist ();
};

class pType: public ::xml_schema::type
{
  public:
  // distribution
  // 
  typedef ::distribution distribution_type;
  typedef ::xsd::cxx::tree::sequence< distribution_type > distribution_sequence;
  typedef distribution_sequence::iterator distribution_iterator;
  typedef distribution_sequence::const_iterator distribution_const_iterator;
  typedef ::xsd::cxx::tree::traits< distribution_type, char > distribution_traits;

  const distribution_sequence&
  distribution () const;

  distribution_sequence&
  distribution ();

  void
  distribution (const distribution_sequence& s);

  // Constructors.
  //
  pType ();

  pType (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  pType (const pType& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual pType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~pType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  distribution_sequence distribution_;
};

class data: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::fileType type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // maxvalue
  // 
  typedef ::xml_schema::int_ maxvalue_type;
  typedef ::xsd::cxx::tree::traits< maxvalue_type, char > maxvalue_traits;

  const maxvalue_type&
  maxvalue () const;

  maxvalue_type&
  maxvalue ();

  void
  maxvalue (const maxvalue_type& x);

  // file
  // 
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_type&
  file () const;

  file_type&
  file ();

  void
  file (const file_type& x);

  void
  file (::std::auto_ptr< file_type > p);

  // startgeneration
  // 
  typedef ::xml_schema::int_ startgeneration_type;
  typedef ::xsd::cxx::tree::optional< startgeneration_type > startgeneration_optional;
  typedef ::xsd::cxx::tree::traits< startgeneration_type, char > startgeneration_traits;

  const startgeneration_optional&
  startgeneration () const;

  startgeneration_optional&
  startgeneration ();

  void
  startgeneration (const startgeneration_type& x);

  void
  startgeneration (const startgeneration_optional& x);

  // endgeneration
  // 
  typedef ::xml_schema::int_ endgeneration_type;
  typedef ::xsd::cxx::tree::optional< endgeneration_type > endgeneration_optional;
  typedef ::xsd::cxx::tree::traits< endgeneration_type, char > endgeneration_traits;

  const endgeneration_optional&
  endgeneration () const;

  endgeneration_optional&
  endgeneration ();

  void
  endgeneration (const endgeneration_type& x);

  void
  endgeneration (const endgeneration_optional& x);

  // Constructors.
  //
  data (const type_type&,
        const maxvalue_type&,
        const file_type&);

  data (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  data (const data& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual data*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~data ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< maxvalue_type > maxvalue_;
  ::xsd::cxx::tree::one< file_type > file_;
  startgeneration_optional startgeneration_;
  endgeneration_optional endgeneration_;
};

class distribution: public ::xml_schema::type
{
  public:
  // p
  // 
  typedef ::intlist p_type;
  typedef ::xsd::cxx::tree::traits< p_type, char > p_traits;

  const p_type&
  p () const;

  p_type&
  p ();

  void
  p (const p_type& x);

  void
  p (::std::auto_ptr< p_type > p);

  // offspring
  // 
  typedef ::intlist offspring_type;
  typedef ::xsd::cxx::tree::traits< offspring_type, char > offspring_traits;

  const offspring_type&
  offspring () const;

  offspring_type&
  offspring ();

  void
  offspring (const offspring_type& x);

  void
  offspring (::std::auto_ptr< offspring_type > p);

  // startgeneration
  // 
  typedef ::xml_schema::int_ startgeneration_type;
  typedef ::xsd::cxx::tree::optional< startgeneration_type > startgeneration_optional;
  typedef ::xsd::cxx::tree::traits< startgeneration_type, char > startgeneration_traits;

  const startgeneration_optional&
  startgeneration () const;

  startgeneration_optional&
  startgeneration ();

  void
  startgeneration (const startgeneration_type& x);

  void
  startgeneration (const startgeneration_optional& x);

  // endgeneration
  // 
  typedef ::xml_schema::int_ endgeneration_type;
  typedef ::xsd::cxx::tree::optional< endgeneration_type > endgeneration_optional;
  typedef ::xsd::cxx::tree::traits< endgeneration_type, char > endgeneration_traits;

  const endgeneration_optional&
  endgeneration () const;

  endgeneration_optional&
  endgeneration ();

  void
  endgeneration (const endgeneration_type& x);

  void
  endgeneration (const endgeneration_optional& x);

  // Constructors.
  //
  distribution (const p_type&,
                const offspring_type&);

  distribution (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  distribution (const distribution& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual distribution*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~distribution ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< p_type > p_;
  ::xsd::cxx::tree::one< offspring_type > offspring_;
  startgeneration_optional startgeneration_;
  endgeneration_optional endgeneration_;
};

class simulation: public ::xml_schema::type
{
  public:
  // seed
  // 
  typedef ::xml_schema::int_ seed_type;
  typedef ::xsd::cxx::tree::traits< seed_type, char > seed_traits;

  const seed_type&
  seed () const;

  seed_type&
  seed ();

  void
  seed (const seed_type& x);

  // generations
  // 
  typedef ::xml_schema::int_ generations_type;
  typedef ::xsd::cxx::tree::traits< generations_type, char > generations_traits;

  const generations_type&
  generations () const;

  generations_type&
  generations ();

  void
  generations (const generations_type& x);

  // latitude
  // 
  typedef ::latitude latitude_type;
  typedef ::xsd::cxx::tree::traits< latitude_type, char > latitude_traits;

  const latitude_type&
  latitude () const;

  latitude_type&
  latitude ();

  void
  latitude (const latitude_type& x);

  void
  latitude (::std::auto_ptr< latitude_type > p);

  // longitude
  // 
  typedef ::longitude longitude_type;
  typedef ::xsd::cxx::tree::traits< longitude_type, char > longitude_traits;

  const longitude_type&
  longitude () const;

  longitude_type&
  longitude ();

  void
  longitude (const longitude_type& x);

  void
  longitude (::std::auto_ptr< longitude_type > p);

  // edges
  // 
  typedef ::edges edges_type;
  typedef ::xsd::cxx::tree::traits< edges_type, char > edges_traits;

  const edges_type&
  edges () const;

  edges_type&
  edges ();

  void
  edges (const edges_type& x);

  void
  edges (::std::auto_ptr< edges_type > p);

  // carryingcapacity
  // 
  typedef ::xyType carryingcapacity_type;
  typedef ::xsd::cxx::tree::traits< carryingcapacity_type, char > carryingcapacity_traits;

  const carryingcapacity_type&
  carryingcapacity () const;

  carryingcapacity_type&
  carryingcapacity ();

  void
  carryingcapacity (const carryingcapacity_type& x);

  void
  carryingcapacity (::std::auto_ptr< carryingcapacity_type > p);

  // hardborders
  // 
  typedef ::xyType hardborders_type;
  typedef ::xsd::cxx::tree::traits< hardborders_type, char > hardborders_traits;

  const hardborders_type&
  hardborders () const;

  hardborders_type&
  hardborders ();

  void
  hardborders (const hardborders_type& x);

  void
  hardborders (::std::auto_ptr< hardborders_type > p);

  // softborders
  // 
  typedef ::xyType softborders_type;
  typedef ::xsd::cxx::tree::traits< softborders_type, char > softborders_traits;

  const softborders_type&
  softborders () const;

  softborders_type&
  softborders ();

  void
  softborders (const softborders_type& x);

  void
  softborders (::std::auto_ptr< softborders_type > p);

  // reproductiveability
  // 
  typedef ::pType reproductiveability_type;
  typedef ::xsd::cxx::tree::traits< reproductiveability_type, char > reproductiveability_traits;

  const reproductiveability_type&
  reproductiveability () const;

  reproductiveability_type&
  reproductiveability ();

  void
  reproductiveability (const reproductiveability_type& x);

  void
  reproductiveability (::std::auto_ptr< reproductiveability_type > p);

  // dispersalradius
  // 
  typedef ::pType dispersalradius_type;
  typedef ::xsd::cxx::tree::traits< dispersalradius_type, char > dispersalradius_traits;

  const dispersalradius_type&
  dispersalradius () const;

  dispersalradius_type&
  dispersalradius ();

  void
  dispersalradius (const dispersalradius_type& x);

  void
  dispersalradius (::std::auto_ptr< dispersalradius_type > p);

  // initialpopulation
  // 
  typedef ::initialpopulation initialpopulation_type;
  typedef ::xsd::cxx::tree::traits< initialpopulation_type, char > initialpopulation_traits;

  const initialpopulation_type&
  initialpopulation () const;

  initialpopulation_type&
  initialpopulation ();

  void
  initialpopulation (const initialpopulation_type& x);

  void
  initialpopulation (::std::auto_ptr< initialpopulation_type > p);

  // output
  // 
  typedef ::output output_type;
  typedef ::xsd::cxx::tree::traits< output_type, char > output_traits;

  const output_type&
  output () const;

  output_type&
  output ();

  void
  output (const output_type& x);

  void
  output (::std::auto_ptr< output_type > p);

  // name
  // 
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // Constructors.
  //
  simulation (const seed_type&,
              const generations_type&,
              const latitude_type&,
              const longitude_type&,
              const edges_type&,
              const carryingcapacity_type&,
              const hardborders_type&,
              const softborders_type&,
              const reproductiveability_type&,
              const dispersalradius_type&,
              const initialpopulation_type&,
              const output_type&,
              const name_type&);

  simulation (const seed_type&,
              const generations_type&,
              ::std::auto_ptr< latitude_type >&,
              ::std::auto_ptr< longitude_type >&,
              ::std::auto_ptr< edges_type >&,
              ::std::auto_ptr< carryingcapacity_type >&,
              ::std::auto_ptr< hardborders_type >&,
              ::std::auto_ptr< softborders_type >&,
              ::std::auto_ptr< reproductiveability_type >&,
              ::std::auto_ptr< dispersalradius_type >&,
              ::std::auto_ptr< initialpopulation_type >&,
              ::std::auto_ptr< output_type >&,
              const name_type&);

  simulation (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  simulation (const simulation& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual simulation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~simulation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< seed_type > seed_;
  ::xsd::cxx::tree::one< generations_type > generations_;
  ::xsd::cxx::tree::one< latitude_type > latitude_;
  ::xsd::cxx::tree::one< longitude_type > longitude_;
  ::xsd::cxx::tree::one< edges_type > edges_;
  ::xsd::cxx::tree::one< carryingcapacity_type > carryingcapacity_;
  ::xsd::cxx::tree::one< hardborders_type > hardborders_;
  ::xsd::cxx::tree::one< softborders_type > softborders_;
  ::xsd::cxx::tree::one< reproductiveability_type > reproductiveability_;
  ::xsd::cxx::tree::one< dispersalradius_type > dispersalradius_;
  ::xsd::cxx::tree::one< initialpopulation_type > initialpopulation_;
  ::xsd::cxx::tree::one< output_type > output_;
  ::xsd::cxx::tree::one< name_type > name_;
};

class latitude: public ::xml_schema::type
{
  public:
  // minimum
  // 
  typedef ::xml_schema::float_ minimum_type;
  typedef ::xsd::cxx::tree::traits< minimum_type, char > minimum_traits;

  const minimum_type&
  minimum () const;

  minimum_type&
  minimum ();

  void
  minimum (const minimum_type& x);

  // maximum
  // 
  typedef ::xml_schema::float_ maximum_type;
  typedef ::xsd::cxx::tree::traits< maximum_type, char > maximum_traits;

  const maximum_type&
  maximum () const;

  maximum_type&
  maximum ();

  void
  maximum (const maximum_type& x);

  // Constructors.
  //
  latitude (const minimum_type&,
            const maximum_type&);

  latitude (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  latitude (const latitude& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual latitude*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~latitude ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< minimum_type > minimum_;
  ::xsd::cxx::tree::one< maximum_type > maximum_;
};

class longitude: public ::xml_schema::type
{
  public:
  // minimum
  // 
  typedef ::xml_schema::float_ minimum_type;
  typedef ::xsd::cxx::tree::traits< minimum_type, char > minimum_traits;

  const minimum_type&
  minimum () const;

  minimum_type&
  minimum ();

  void
  minimum (const minimum_type& x);

  // maximum
  // 
  typedef ::xml_schema::float_ maximum_type;
  typedef ::xsd::cxx::tree::traits< maximum_type, char > maximum_traits;

  const maximum_type&
  maximum () const;

  maximum_type&
  maximum ();

  void
  maximum (const maximum_type& x);

  // Constructors.
  //
  longitude (const minimum_type&,
             const maximum_type&);

  longitude (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  longitude (const longitude& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual longitude*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~longitude ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< minimum_type > minimum_;
  ::xsd::cxx::tree::one< maximum_type > maximum_;
};

class edges: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::xml_schema::string type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // Constructors.
  //
  edges (const type_type&);

  edges (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  edges (const edges& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual edges*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~edges ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< type_type > type_;
};

class initialpopulation: public ::xml_schema::type
{
  public:
  // node
  // 
  typedef ::node node_type;
  typedef ::xsd::cxx::tree::sequence< node_type > node_sequence;
  typedef node_sequence::iterator node_iterator;
  typedef node_sequence::const_iterator node_const_iterator;
  typedef ::xsd::cxx::tree::traits< node_type, char > node_traits;

  const node_sequence&
  node () const;

  node_sequence&
  node ();

  void
  node (const node_sequence& s);

  // Constructors.
  //
  initialpopulation ();

  initialpopulation (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  initialpopulation (const initialpopulation& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual initialpopulation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~initialpopulation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  node_sequence node_;
};

class output: public ::xml_schema::type
{
  public:
  // visual
  // 
  typedef ::visual visual_type;
  typedef ::xsd::cxx::tree::optional< visual_type > visual_optional;
  typedef ::xsd::cxx::tree::traits< visual_type, char > visual_traits;

  const visual_optional&
  visual () const;

  visual_optional&
  visual ();

  void
  visual (const visual_type& x);

  void
  visual (const visual_optional& x);

  void
  visual (::std::auto_ptr< visual_type > p);

  // treestructure
  // 
  typedef ::treestructure treestructure_type;
  typedef ::xsd::cxx::tree::sequence< treestructure_type > treestructure_sequence;
  typedef treestructure_sequence::iterator treestructure_iterator;
  typedef treestructure_sequence::const_iterator treestructure_const_iterator;
  typedef ::xsd::cxx::tree::traits< treestructure_type, char > treestructure_traits;

  const treestructure_sequence&
  treestructure () const;

  treestructure_sequence&
  treestructure ();

  void
  treestructure (const treestructure_sequence& s);

  // locations
  // 
  typedef ::locations locations_type;
  typedef ::xsd::cxx::tree::sequence< locations_type > locations_sequence;
  typedef locations_sequence::iterator locations_iterator;
  typedef locations_sequence::const_iterator locations_const_iterator;
  typedef ::xsd::cxx::tree::traits< locations_type, char > locations_traits;

  const locations_sequence&
  locations () const;

  locations_sequence&
  locations ();

  void
  locations (const locations_sequence& s);

  // Constructors.
  //
  output ();

  output (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  output (const output& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual output*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~output ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  visual_optional visual_;
  treestructure_sequence treestructure_;
  locations_sequence locations_;
};

class node: public ::xml_schema::type
{
  public:
  // lat
  // 
  typedef ::xml_schema::float_ lat_type;
  typedef ::xsd::cxx::tree::traits< lat_type, char > lat_traits;

  const lat_type&
  lat () const;

  lat_type&
  lat ();

  void
  lat (const lat_type& x);

  // lon
  // 
  typedef ::xml_schema::float_ lon_type;
  typedef ::xsd::cxx::tree::traits< lon_type, char > lon_traits;

  const lon_type&
  lon () const;

  lon_type&
  lon ();

  void
  lon (const lon_type& x);

  // n
  // 
  typedef ::xml_schema::int_ n_type;
  typedef ::xsd::cxx::tree::traits< n_type, char > n_traits;

  const n_type&
  n () const;

  n_type&
  n ();

  void
  n (const n_type& x);

  // r
  // 
  typedef ::xml_schema::int_ r_type;
  typedef ::xsd::cxx::tree::traits< r_type, char > r_traits;

  const r_type&
  r () const;

  r_type&
  r ();

  void
  r (const r_type& x);

  // g
  // 
  typedef ::xml_schema::int_ g_type;
  typedef ::xsd::cxx::tree::traits< g_type, char > g_traits;

  const g_type&
  g () const;

  g_type&
  g ();

  void
  g (const g_type& x);

  // b
  // 
  typedef ::xml_schema::int_ b_type;
  typedef ::xsd::cxx::tree::traits< b_type, char > b_traits;

  const b_type&
  b () const;

  b_type&
  b ();

  void
  b (const b_type& x);

  // Constructors.
  //
  node (const lat_type&,
        const lon_type&,
        const n_type&,
        const r_type&,
        const g_type&,
        const b_type&);

  node (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  node (const node& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual node*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~node ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< lat_type > lat_;
  ::xsd::cxx::tree::one< lon_type > lon_;
  ::xsd::cxx::tree::one< n_type > n_;
  ::xsd::cxx::tree::one< r_type > r_;
  ::xsd::cxx::tree::one< g_type > g_;
  ::xsd::cxx::tree::one< b_type > b_;
};

class visual: public ::xml_schema::type
{
  public:
  // output_every
  // 
  typedef ::xml_schema::int_ output_every_type;
  typedef ::xsd::cxx::tree::traits< output_every_type, char > output_every_traits;

  const output_every_type&
  output_every () const;

  output_every_type&
  output_every ();

  void
  output_every (const output_every_type& x);

  // xsize
  // 
  typedef ::xml_schema::int_ xsize_type;
  typedef ::xsd::cxx::tree::optional< xsize_type > xsize_optional;
  typedef ::xsd::cxx::tree::traits< xsize_type, char > xsize_traits;

  const xsize_optional&
  xsize () const;

  xsize_optional&
  xsize ();

  void
  xsize (const xsize_type& x);

  void
  xsize (const xsize_optional& x);

  // ysize
  // 
  typedef ::xml_schema::int_ ysize_type;
  typedef ::xsd::cxx::tree::optional< ysize_type > ysize_optional;
  typedef ::xsd::cxx::tree::traits< ysize_type, char > ysize_traits;

  const ysize_optional&
  ysize () const;

  ysize_optional&
  ysize ();

  void
  ysize (const ysize_type& x);

  void
  ysize (const ysize_optional& x);

  // Constructors.
  //
  visual (const output_every_type&);

  visual (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  visual (const visual& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual visual*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~visual ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< output_every_type > output_every_;
  xsize_optional xsize_;
  ysize_optional ysize_;
};

class treestructure: public ::xml_schema::type
{
  public:
  // delimeter
  // 
  typedef ::xml_schema::string delimeter_type;
  typedef ::xsd::cxx::tree::optional< delimeter_type > delimeter_optional;
  typedef ::xsd::cxx::tree::traits< delimeter_type, char > delimeter_traits;

  const delimeter_optional&
  delimeter () const;

  delimeter_optional&
  delimeter ();

  void
  delimeter (const delimeter_type& x);

  void
  delimeter (const delimeter_optional& x);

  void
  delimeter (::std::auto_ptr< delimeter_type > p);

  // output
  // 
  typedef ::treeType output_type;
  typedef ::xsd::cxx::tree::traits< output_type, char > output_traits;

  const output_type&
  output () const;

  output_type&
  output ();

  void
  output (const output_type& x);

  void
  output (::std::auto_ptr< output_type > p);

  // file
  // 
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_type&
  file () const;

  file_type&
  file ();

  void
  file (const file_type& x);

  void
  file (::std::auto_ptr< file_type > p);

  // trim
  // 
  typedef ::xml_schema::boolean trim_type;
  typedef ::xsd::cxx::tree::optional< trim_type > trim_optional;
  typedef ::xsd::cxx::tree::traits< trim_type, char > trim_traits;

  const trim_optional&
  trim () const;

  trim_optional&
  trim ();

  void
  trim (const trim_type& x);

  void
  trim (const trim_optional& x);

  // resolve
  // 
  typedef ::xml_schema::boolean resolve_type;
  typedef ::xsd::cxx::tree::optional< resolve_type > resolve_optional;
  typedef ::xsd::cxx::tree::traits< resolve_type, char > resolve_traits;

  const resolve_optional&
  resolve () const;

  resolve_optional&
  resolve ();

  void
  resolve (const resolve_type& x);

  void
  resolve (const resolve_optional& x);

  // mutationrate
  // 
  typedef ::xml_schema::float_ mutationrate_type;
  typedef ::xsd::cxx::tree::optional< mutationrate_type > mutationrate_optional;
  typedef ::xsd::cxx::tree::traits< mutationrate_type, char > mutationrate_traits;

  const mutationrate_optional&
  mutationrate () const;

  mutationrate_optional&
  mutationrate ();

  void
  mutationrate (const mutationrate_type& x);

  void
  mutationrate (const mutationrate_optional& x);

  // output_every
  // 
  typedef ::xml_schema::int_ output_every_type;
  typedef ::xsd::cxx::tree::traits< output_every_type, char > output_every_traits;

  const output_every_type&
  output_every () const;

  output_every_type&
  output_every ();

  void
  output_every (const output_every_type& x);

  // Constructors.
  //
  treestructure (const output_type&,
                 const file_type&,
                 const output_every_type&);

  treestructure (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  treestructure (const treestructure& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual treestructure*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~treestructure ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  delimeter_optional delimeter_;
  ::xsd::cxx::tree::one< output_type > output_;
  ::xsd::cxx::tree::one< file_type > file_;
  trim_optional trim_;
  resolve_optional resolve_;
  mutationrate_optional mutationrate_;
  ::xsd::cxx::tree::one< output_every_type > output_every_;
};

class locations: public ::xml_schema::type
{
  public:
  // generation
  // 
  typedef ::locType generation_type;
  typedef ::xsd::cxx::tree::traits< generation_type, char > generation_traits;

  const generation_type&
  generation () const;

  generation_type&
  generation ();

  void
  generation (const generation_type& x);

  void
  generation (::std::auto_ptr< generation_type > p);

  // file
  // 
  typedef ::xml_schema::string file_type;
  typedef ::xsd::cxx::tree::traits< file_type, char > file_traits;

  const file_type&
  file () const;

  file_type&
  file ();

  void
  file (const file_type& x);

  void
  file (::std::auto_ptr< file_type > p);

  // output_every
  // 
  typedef ::xml_schema::int_ output_every_type;
  typedef ::xsd::cxx::tree::traits< output_every_type, char > output_every_traits;

  const output_every_type&
  output_every () const;

  output_every_type&
  output_every ();

  void
  output_every (const output_every_type& x);

  // Constructors.
  //
  locations (const generation_type&,
             const file_type&,
             const output_every_type&);

  locations (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  locations (const locations& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual locations*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~locations ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< generation_type > generation_;
  ::xsd::cxx::tree::one< file_type > file_;
  ::xsd::cxx::tree::one< output_every_type > output_every_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::simulation >
simulation_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::simulation >
simulation_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CONFIG_FILE_HXX
