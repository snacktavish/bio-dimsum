// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ConfigFile.h"

// edgeType
// 

edgeType::
edgeType (value v)
: ::xml_schema::string (_xsd_edgeType_literals_[v])
{
}

edgeType::
edgeType (const char* v)
: ::xml_schema::string (v)
{
}

edgeType::
edgeType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

edgeType::
edgeType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

edgeType::
edgeType (const edgeType& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

edgeType& edgeType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_edgeType_literals_[v]);

  return *this;
}


// fileType
// 

fileType::
fileType (value v)
: ::xml_schema::string (_xsd_fileType_literals_[v])
{
}

fileType::
fileType (const char* v)
: ::xml_schema::string (v)
{
}

fileType::
fileType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

fileType::
fileType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

fileType::
fileType (const fileType& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

fileType& fileType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_fileType_literals_[v]);

  return *this;
}


// treeType
// 

treeType::
treeType (value v)
: ::xml_schema::string (_xsd_treeType_literals_[v])
{
}

treeType::
treeType (const char* v)
: ::xml_schema::string (v)
{
}

treeType::
treeType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

treeType::
treeType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

treeType::
treeType (const treeType& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

treeType& treeType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_treeType_literals_[v]);

  return *this;
}


// sexType
// 

sexType::
sexType (value v)
: ::xml_schema::string (_xsd_sexType_literals_[v])
{
}

sexType::
sexType (const char* v)
: ::xml_schema::string (v)
{
}

sexType::
sexType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

sexType::
sexType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

sexType::
sexType (const sexType& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

sexType& sexType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_sexType_literals_[v]);

  return *this;
}


// locType
// 

locType::
locType (value v)
: ::xml_schema::string (_xsd_locType_literals_[v])
{
}

locType::
locType (const char* v)
: ::xml_schema::string (v)
{
}

locType::
locType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

locType::
locType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

locType::
locType (const locType& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

locType& locType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_locType_literals_[v]);

  return *this;
}


// xyType
// 

const xyType::data_sequence& xyType::
data () const
{
  return this->data_;
}

xyType::data_sequence& xyType::
data ()
{
  return this->data_;
}

void xyType::
data (const data_sequence& s)
{
  this->data_ = s;
}


// floatlist
//

floatlist::
floatlist ()
: ::xsd::cxx::tree::list< ::xml_schema::float_, char > ( ::xml_schema::flags (0), this)
{
}

floatlist::
floatlist (size_type n, const ::xml_schema::float_& x)
: ::xsd::cxx::tree::list< ::xml_schema::float_, char > (n, x, this)
{
}

floatlist::
floatlist (const floatlist& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::float_, char > (o, f, this)
{
}

// integerlist
//

integerlist::
integerlist ()
: ::xsd::cxx::tree::list< ::xml_schema::int_, char > ( ::xml_schema::flags (0), this)
{
}

integerlist::
integerlist (size_type n, const ::xml_schema::int_& x)
: ::xsd::cxx::tree::list< ::xml_schema::int_, char > (n, x, this)
{
}

integerlist::
integerlist (const integerlist& o,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (o, f, this)
{
}

// pType
// 

const pType::distribution_sequence& pType::
distribution () const
{
  return this->distribution_;
}

pType::distribution_sequence& pType::
distribution ()
{
  return this->distribution_;
}

void pType::
distribution (const distribution_sequence& s)
{
  this->distribution_ = s;
}


// data
// 

const data::type_type& data::
type () const
{
  return this->type_.get ();
}

data::type_type& data::
type ()
{
  return this->type_.get ();
}

void data::
type (const type_type& x)
{
  this->type_.set (x);
}

void data::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const data::maxvalue_type& data::
maxvalue () const
{
  return this->maxvalue_.get ();
}

data::maxvalue_type& data::
maxvalue ()
{
  return this->maxvalue_.get ();
}

void data::
maxvalue (const maxvalue_type& x)
{
  this->maxvalue_.set (x);
}

const data::file_type& data::
file () const
{
  return this->file_.get ();
}

data::file_type& data::
file ()
{
  return this->file_.get ();
}

void data::
file (const file_type& x)
{
  this->file_.set (x);
}

void data::
file (::std::auto_ptr< file_type > x)
{
  this->file_.set (x);
}

const data::startgeneration_optional& data::
startgeneration () const
{
  return this->startgeneration_;
}

data::startgeneration_optional& data::
startgeneration ()
{
  return this->startgeneration_;
}

void data::
startgeneration (const startgeneration_type& x)
{
  this->startgeneration_.set (x);
}

void data::
startgeneration (const startgeneration_optional& x)
{
  this->startgeneration_ = x;
}

const data::endgeneration_optional& data::
endgeneration () const
{
  return this->endgeneration_;
}

data::endgeneration_optional& data::
endgeneration ()
{
  return this->endgeneration_;
}

void data::
endgeneration (const endgeneration_type& x)
{
  this->endgeneration_.set (x);
}

void data::
endgeneration (const endgeneration_optional& x)
{
  this->endgeneration_ = x;
}


// distribution
// 

const distribution::p_type& distribution::
p () const
{
  return this->p_.get ();
}

distribution::p_type& distribution::
p ()
{
  return this->p_.get ();
}

void distribution::
p (const p_type& x)
{
  this->p_.set (x);
}

void distribution::
p (::std::auto_ptr< p_type > x)
{
  this->p_.set (x);
}

const distribution::offspring_type& distribution::
offspring () const
{
  return this->offspring_.get ();
}

distribution::offspring_type& distribution::
offspring ()
{
  return this->offspring_.get ();
}

void distribution::
offspring (const offspring_type& x)
{
  this->offspring_.set (x);
}

void distribution::
offspring (::std::auto_ptr< offspring_type > x)
{
  this->offspring_.set (x);
}

const distribution::startgeneration_optional& distribution::
startgeneration () const
{
  return this->startgeneration_;
}

distribution::startgeneration_optional& distribution::
startgeneration ()
{
  return this->startgeneration_;
}

void distribution::
startgeneration (const startgeneration_type& x)
{
  this->startgeneration_.set (x);
}

void distribution::
startgeneration (const startgeneration_optional& x)
{
  this->startgeneration_ = x;
}

const distribution::endgeneration_optional& distribution::
endgeneration () const
{
  return this->endgeneration_;
}

distribution::endgeneration_optional& distribution::
endgeneration ()
{
  return this->endgeneration_;
}

void distribution::
endgeneration (const endgeneration_type& x)
{
  this->endgeneration_.set (x);
}

void distribution::
endgeneration (const endgeneration_optional& x)
{
  this->endgeneration_ = x;
}


// simulation
// 

const simulation::seed_type& simulation::
seed () const
{
  return this->seed_.get ();
}

simulation::seed_type& simulation::
seed ()
{
  return this->seed_.get ();
}

void simulation::
seed (const seed_type& x)
{
  this->seed_.set (x);
}

const simulation::generations_type& simulation::
generations () const
{
  return this->generations_.get ();
}

simulation::generations_type& simulation::
generations ()
{
  return this->generations_.get ();
}

void simulation::
generations (const generations_type& x)
{
  this->generations_.set (x);
}

const simulation::latitude_type& simulation::
latitude () const
{
  return this->latitude_.get ();
}

simulation::latitude_type& simulation::
latitude ()
{
  return this->latitude_.get ();
}

void simulation::
latitude (const latitude_type& x)
{
  this->latitude_.set (x);
}

void simulation::
latitude (::std::auto_ptr< latitude_type > x)
{
  this->latitude_.set (x);
}

const simulation::longitude_type& simulation::
longitude () const
{
  return this->longitude_.get ();
}

simulation::longitude_type& simulation::
longitude ()
{
  return this->longitude_.get ();
}

void simulation::
longitude (const longitude_type& x)
{
  this->longitude_.set (x);
}

void simulation::
longitude (::std::auto_ptr< longitude_type > x)
{
  this->longitude_.set (x);
}

const simulation::edges_type& simulation::
edges () const
{
  return this->edges_.get ();
}

simulation::edges_type& simulation::
edges ()
{
  return this->edges_.get ();
}

void simulation::
edges (const edges_type& x)
{
  this->edges_.set (x);
}

void simulation::
edges (::std::auto_ptr< edges_type > x)
{
  this->edges_.set (x);
}

const simulation::carryingcapacity_type& simulation::
carryingcapacity () const
{
  return this->carryingcapacity_.get ();
}

simulation::carryingcapacity_type& simulation::
carryingcapacity ()
{
  return this->carryingcapacity_.get ();
}

void simulation::
carryingcapacity (const carryingcapacity_type& x)
{
  this->carryingcapacity_.set (x);
}

void simulation::
carryingcapacity (::std::auto_ptr< carryingcapacity_type > x)
{
  this->carryingcapacity_.set (x);
}

const simulation::hardborders_type& simulation::
hardborders () const
{
  return this->hardborders_.get ();
}

simulation::hardborders_type& simulation::
hardborders ()
{
  return this->hardborders_.get ();
}

void simulation::
hardborders (const hardborders_type& x)
{
  this->hardborders_.set (x);
}

void simulation::
hardborders (::std::auto_ptr< hardborders_type > x)
{
  this->hardborders_.set (x);
}

const simulation::softborders_type& simulation::
softborders () const
{
  return this->softborders_.get ();
}

simulation::softborders_type& simulation::
softborders ()
{
  return this->softborders_.get ();
}

void simulation::
softborders (const softborders_type& x)
{
  this->softborders_.set (x);
}

void simulation::
softborders (::std::auto_ptr< softborders_type > x)
{
  this->softborders_.set (x);
}

const simulation::reproductiveability_type& simulation::
reproductiveability () const
{
  return this->reproductiveability_.get ();
}

simulation::reproductiveability_type& simulation::
reproductiveability ()
{
  return this->reproductiveability_.get ();
}

void simulation::
reproductiveability (const reproductiveability_type& x)
{
  this->reproductiveability_.set (x);
}

void simulation::
reproductiveability (::std::auto_ptr< reproductiveability_type > x)
{
  this->reproductiveability_.set (x);
}

const simulation::dispersalradius_type& simulation::
dispersalradius () const
{
  return this->dispersalradius_.get ();
}

simulation::dispersalradius_type& simulation::
dispersalradius ()
{
  return this->dispersalradius_.get ();
}

void simulation::
dispersalradius (const dispersalradius_type& x)
{
  this->dispersalradius_.set (x);
}

void simulation::
dispersalradius (::std::auto_ptr< dispersalradius_type > x)
{
  this->dispersalradius_.set (x);
}

const simulation::loci_type& simulation::
loci () const
{
  return this->loci_.get ();
}

simulation::loci_type& simulation::
loci ()
{
  return this->loci_.get ();
}

void simulation::
loci (const loci_type& x)
{
  this->loci_.set (x);
}

void simulation::
loci (::std::auto_ptr< loci_type > x)
{
  this->loci_.set (x);
}

const simulation::initialpopulation_type& simulation::
initialpopulation () const
{
  return this->initialpopulation_.get ();
}

simulation::initialpopulation_type& simulation::
initialpopulation ()
{
  return this->initialpopulation_.get ();
}

void simulation::
initialpopulation (const initialpopulation_type& x)
{
  this->initialpopulation_.set (x);
}

void simulation::
initialpopulation (::std::auto_ptr< initialpopulation_type > x)
{
  this->initialpopulation_.set (x);
}

const simulation::output_type& simulation::
output () const
{
  return this->output_.get ();
}

simulation::output_type& simulation::
output ()
{
  return this->output_.get ();
}

void simulation::
output (const output_type& x)
{
  this->output_.set (x);
}

void simulation::
output (::std::auto_ptr< output_type > x)
{
  this->output_.set (x);
}

const simulation::name_type& simulation::
name () const
{
  return this->name_.get ();
}

simulation::name_type& simulation::
name ()
{
  return this->name_.get ();
}

void simulation::
name (const name_type& x)
{
  this->name_.set (x);
}

void simulation::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// latitude
// 

const latitude::minimum_type& latitude::
minimum () const
{
  return this->minimum_.get ();
}

latitude::minimum_type& latitude::
minimum ()
{
  return this->minimum_.get ();
}

void latitude::
minimum (const minimum_type& x)
{
  this->minimum_.set (x);
}

const latitude::maximum_type& latitude::
maximum () const
{
  return this->maximum_.get ();
}

latitude::maximum_type& latitude::
maximum ()
{
  return this->maximum_.get ();
}

void latitude::
maximum (const maximum_type& x)
{
  this->maximum_.set (x);
}


// longitude
// 

const longitude::minimum_type& longitude::
minimum () const
{
  return this->minimum_.get ();
}

longitude::minimum_type& longitude::
minimum ()
{
  return this->minimum_.get ();
}

void longitude::
minimum (const minimum_type& x)
{
  this->minimum_.set (x);
}

const longitude::maximum_type& longitude::
maximum () const
{
  return this->maximum_.get ();
}

longitude::maximum_type& longitude::
maximum ()
{
  return this->maximum_.get ();
}

void longitude::
maximum (const maximum_type& x)
{
  this->maximum_.set (x);
}


// edges
// 

const edges::type_type& edges::
type () const
{
  return this->type_.get ();
}

edges::type_type& edges::
type ()
{
  return this->type_.get ();
}

void edges::
type (const type_type& x)
{
  this->type_.set (x);
}

void edges::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// loci
// 

const loci::numloci_type& loci::
numloci () const
{
  return this->numloci_.get ();
}

loci::numloci_type& loci::
numloci ()
{
  return this->numloci_.get ();
}

void loci::
numloci (const numloci_type& x)
{
  this->numloci_.set (x);
}

const loci::recombinationrate_type& loci::
recombinationrate () const
{
  return this->recombinationrate_.get ();
}

loci::recombinationrate_type& loci::
recombinationrate ()
{
  return this->recombinationrate_.get ();
}

void loci::
recombinationrate (const recombinationrate_type& x)
{
  this->recombinationrate_.set (x);
}

void loci::
recombinationrate (::std::auto_ptr< recombinationrate_type > x)
{
  this->recombinationrate_.set (x);
}


// initialpopulation
// 

const initialpopulation::node_sequence& initialpopulation::
node () const
{
  return this->node_;
}

initialpopulation::node_sequence& initialpopulation::
node ()
{
  return this->node_;
}

void initialpopulation::
node (const node_sequence& s)
{
  this->node_ = s;
}


// output
// 

const output::visual_optional& output::
visual () const
{
  return this->visual_;
}

output::visual_optional& output::
visual ()
{
  return this->visual_;
}

void output::
visual (const visual_type& x)
{
  this->visual_.set (x);
}

void output::
visual (const visual_optional& x)
{
  this->visual_ = x;
}

void output::
visual (::std::auto_ptr< visual_type > x)
{
  this->visual_.set (x);
}

const output::treestructure_sequence& output::
treestructure () const
{
  return this->treestructure_;
}

output::treestructure_sequence& output::
treestructure ()
{
  return this->treestructure_;
}

void output::
treestructure (const treestructure_sequence& s)
{
  this->treestructure_ = s;
}

const output::locations_sequence& output::
locations () const
{
  return this->locations_;
}

output::locations_sequence& output::
locations ()
{
  return this->locations_;
}

void output::
locations (const locations_sequence& s)
{
  this->locations_ = s;
}

const output::ndna_sequence& output::
ndna () const
{
  return this->ndna_;
}

output::ndna_sequence& output::
ndna ()
{
  return this->ndna_;
}

void output::
ndna (const ndna_sequence& s)
{
  this->ndna_ = s;
}


// node
// 

const node::lat_type& node::
lat () const
{
  return this->lat_.get ();
}

node::lat_type& node::
lat ()
{
  return this->lat_.get ();
}

void node::
lat (const lat_type& x)
{
  this->lat_.set (x);
}

const node::lon_type& node::
lon () const
{
  return this->lon_.get ();
}

node::lon_type& node::
lon ()
{
  return this->lon_.get ();
}

void node::
lon (const lon_type& x)
{
  this->lon_.set (x);
}

const node::n_type& node::
n () const
{
  return this->n_.get ();
}

node::n_type& node::
n ()
{
  return this->n_.get ();
}

void node::
n (const n_type& x)
{
  this->n_.set (x);
}

const node::r_type& node::
r () const
{
  return this->r_.get ();
}

node::r_type& node::
r ()
{
  return this->r_.get ();
}

void node::
r (const r_type& x)
{
  this->r_.set (x);
}

const node::g_type& node::
g () const
{
  return this->g_.get ();
}

node::g_type& node::
g ()
{
  return this->g_.get ();
}

void node::
g (const g_type& x)
{
  this->g_.set (x);
}

const node::b_type& node::
b () const
{
  return this->b_.get ();
}

node::b_type& node::
b ()
{
  return this->b_.get ();
}

void node::
b (const b_type& x)
{
  this->b_.set (x);
}

const node::sex_type& node::
sex () const
{
  return this->sex_.get ();
}

node::sex_type& node::
sex ()
{
  return this->sex_.get ();
}

void node::
sex (const sex_type& x)
{
  this->sex_.set (x);
}

void node::
sex (::std::auto_ptr< sex_type > x)
{
  this->sex_.set (x);
}

const node::mloci_type& node::
mloci () const
{
  return this->mloci_.get ();
}

node::mloci_type& node::
mloci ()
{
  return this->mloci_.get ();
}

void node::
mloci (const mloci_type& x)
{
  this->mloci_.set (x);
}

void node::
mloci (::std::auto_ptr< mloci_type > x)
{
  this->mloci_.set (x);
}

const node::floci_type& node::
floci () const
{
  return this->floci_.get ();
}

node::floci_type& node::
floci ()
{
  return this->floci_.get ();
}

void node::
floci (const floci_type& x)
{
  this->floci_.set (x);
}

void node::
floci (::std::auto_ptr< floci_type > x)
{
  this->floci_.set (x);
}


// visual
// 

const visual::output_every_type& visual::
output_every () const
{
  return this->output_every_.get ();
}

visual::output_every_type& visual::
output_every ()
{
  return this->output_every_.get ();
}

void visual::
output_every (const output_every_type& x)
{
  this->output_every_.set (x);
}

const visual::xsize_optional& visual::
xsize () const
{
  return this->xsize_;
}

visual::xsize_optional& visual::
xsize ()
{
  return this->xsize_;
}

void visual::
xsize (const xsize_type& x)
{
  this->xsize_.set (x);
}

void visual::
xsize (const xsize_optional& x)
{
  this->xsize_ = x;
}

const visual::ysize_optional& visual::
ysize () const
{
  return this->ysize_;
}

visual::ysize_optional& visual::
ysize ()
{
  return this->ysize_;
}

void visual::
ysize (const ysize_type& x)
{
  this->ysize_.set (x);
}

void visual::
ysize (const ysize_optional& x)
{
  this->ysize_ = x;
}


// treestructure
// 

const treestructure::delimeter_optional& treestructure::
delimeter () const
{
  return this->delimeter_;
}

treestructure::delimeter_optional& treestructure::
delimeter ()
{
  return this->delimeter_;
}

void treestructure::
delimeter (const delimeter_type& x)
{
  this->delimeter_.set (x);
}

void treestructure::
delimeter (const delimeter_optional& x)
{
  this->delimeter_ = x;
}

void treestructure::
delimeter (::std::auto_ptr< delimeter_type > x)
{
  this->delimeter_.set (x);
}

const treestructure::output_type& treestructure::
output () const
{
  return this->output_.get ();
}

treestructure::output_type& treestructure::
output ()
{
  return this->output_.get ();
}

void treestructure::
output (const output_type& x)
{
  this->output_.set (x);
}

void treestructure::
output (::std::auto_ptr< output_type > x)
{
  this->output_.set (x);
}

const treestructure::file_type& treestructure::
file () const
{
  return this->file_.get ();
}

treestructure::file_type& treestructure::
file ()
{
  return this->file_.get ();
}

void treestructure::
file (const file_type& x)
{
  this->file_.set (x);
}

void treestructure::
file (::std::auto_ptr< file_type > x)
{
  this->file_.set (x);
}

const treestructure::trim_optional& treestructure::
trim () const
{
  return this->trim_;
}

treestructure::trim_optional& treestructure::
trim ()
{
  return this->trim_;
}

void treestructure::
trim (const trim_type& x)
{
  this->trim_.set (x);
}

void treestructure::
trim (const trim_optional& x)
{
  this->trim_ = x;
}

const treestructure::resolve_optional& treestructure::
resolve () const
{
  return this->resolve_;
}

treestructure::resolve_optional& treestructure::
resolve ()
{
  return this->resolve_;
}

void treestructure::
resolve (const resolve_type& x)
{
  this->resolve_.set (x);
}

void treestructure::
resolve (const resolve_optional& x)
{
  this->resolve_ = x;
}

const treestructure::mutationrate_optional& treestructure::
mutationrate () const
{
  return this->mutationrate_;
}

treestructure::mutationrate_optional& treestructure::
mutationrate ()
{
  return this->mutationrate_;
}

void treestructure::
mutationrate (const mutationrate_type& x)
{
  this->mutationrate_.set (x);
}

void treestructure::
mutationrate (const mutationrate_optional& x)
{
  this->mutationrate_ = x;
}

const treestructure::output_every_type& treestructure::
output_every () const
{
  return this->output_every_.get ();
}

treestructure::output_every_type& treestructure::
output_every ()
{
  return this->output_every_.get ();
}

void treestructure::
output_every (const output_every_type& x)
{
  this->output_every_.set (x);
}


// locations
// 

const locations::generation_type& locations::
generation () const
{
  return this->generation_.get ();
}

locations::generation_type& locations::
generation ()
{
  return this->generation_.get ();
}

void locations::
generation (const generation_type& x)
{
  this->generation_.set (x);
}

void locations::
generation (::std::auto_ptr< generation_type > x)
{
  this->generation_.set (x);
}

const locations::file_type& locations::
file () const
{
  return this->file_.get ();
}

locations::file_type& locations::
file ()
{
  return this->file_.get ();
}

void locations::
file (const file_type& x)
{
  this->file_.set (x);
}

void locations::
file (::std::auto_ptr< file_type > x)
{
  this->file_.set (x);
}

const locations::output_every_type& locations::
output_every () const
{
  return this->output_every_.get ();
}

locations::output_every_type& locations::
output_every ()
{
  return this->output_every_.get ();
}

void locations::
output_every (const output_every_type& x)
{
  this->output_every_.set (x);
}


// ndna
// 

const ndna::delimeter_optional& ndna::
delimeter () const
{
  return this->delimeter_;
}

ndna::delimeter_optional& ndna::
delimeter ()
{
  return this->delimeter_;
}

void ndna::
delimeter (const delimeter_type& x)
{
  this->delimeter_.set (x);
}

void ndna::
delimeter (const delimeter_optional& x)
{
  this->delimeter_ = x;
}

void ndna::
delimeter (::std::auto_ptr< delimeter_type > x)
{
  this->delimeter_.set (x);
}

const ndna::file_type& ndna::
file () const
{
  return this->file_.get ();
}

ndna::file_type& ndna::
file ()
{
  return this->file_.get ();
}

void ndna::
file (const file_type& x)
{
  this->file_.set (x);
}

void ndna::
file (::std::auto_ptr< file_type > x)
{
  this->file_.set (x);
}

const ndna::trim_optional& ndna::
trim () const
{
  return this->trim_;
}

ndna::trim_optional& ndna::
trim ()
{
  return this->trim_;
}

void ndna::
trim (const trim_type& x)
{
  this->trim_.set (x);
}

void ndna::
trim (const trim_optional& x)
{
  this->trim_ = x;
}

const ndna::output_every_type& ndna::
output_every () const
{
  return this->output_every_.get ();
}

ndna::output_every_type& ndna::
output_every ()
{
  return this->output_every_.get ();
}

void ndna::
output_every (const output_every_type& x)
{
  this->output_every_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// edgeType
//

edgeType::
edgeType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_edgeType_convert ();
}

edgeType::
edgeType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_edgeType_convert ();
}

edgeType::
edgeType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_edgeType_convert ();
}

edgeType* edgeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class edgeType (*this, f, c);
}

edgeType::value edgeType::
_xsd_edgeType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_edgeType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_edgeType_indexes_,
                    _xsd_edgeType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_edgeType_indexes_ + 2 || _xsd_edgeType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const edgeType::
_xsd_edgeType_literals_[2] =
{
  "impenetrable",
  "deadly"
};

const edgeType::value edgeType::
_xsd_edgeType_indexes_[2] =
{
  ::edgeType::deadly,
  ::edgeType::impenetrable
};

// fileType
//

fileType::
fileType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_fileType_convert ();
}

fileType::
fileType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_fileType_convert ();
}

fileType::
fileType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_fileType_convert ();
}

fileType* fileType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class fileType (*this, f, c);
}

fileType::value fileType::
_xsd_fileType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_fileType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_fileType_indexes_,
                    _xsd_fileType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_fileType_indexes_ + 2 || _xsd_fileType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const fileType::
_xsd_fileType_literals_[2] =
{
  "image",
  "file"
};

const fileType::value fileType::
_xsd_fileType_indexes_[2] =
{
  ::fileType::file,
  ::fileType::image
};

// treeType
//

treeType::
treeType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_treeType_convert ();
}

treeType::
treeType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_treeType_convert ();
}

treeType::
treeType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_treeType_convert ();
}

treeType* treeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class treeType (*this, f, c);
}

treeType::value treeType::
_xsd_treeType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_treeType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_treeType_indexes_,
                    _xsd_treeType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_treeType_indexes_ + 2 || _xsd_treeType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const treeType::
_xsd_treeType_literals_[2] =
{
  "parent",
  "distance"
};

const treeType::value treeType::
_xsd_treeType_indexes_[2] =
{
  ::treeType::distance,
  ::treeType::parent
};

// sexType
//

sexType::
sexType (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_sexType_convert ();
}

sexType::
sexType (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_sexType_convert ();
}

sexType::
sexType (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_sexType_convert ();
}

sexType* sexType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sexType (*this, f, c);
}

sexType::value sexType::
_xsd_sexType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_sexType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_sexType_indexes_,
                    _xsd_sexType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_sexType_indexes_ + 2 || _xsd_sexType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const sexType::
_xsd_sexType_literals_[2] =
{
  "male",
  "female"
};

const sexType::value sexType::
_xsd_sexType_indexes_[2] =
{
  ::sexType::female,
  ::sexType::male
};

// locType
//

locType::
locType (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_locType_convert ();
}

locType::
locType (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_locType_convert ();
}

locType::
locType (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_locType_convert ();
}

locType* locType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class locType (*this, f, c);
}

locType::value locType::
_xsd_locType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_locType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_locType_indexes_,
                    _xsd_locType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_locType_indexes_ + 2 || _xsd_locType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const locType::
_xsd_locType_literals_[2] =
{
  "all",
  "last"
};

const locType::value locType::
_xsd_locType_indexes_[2] =
{
  ::locType::all,
  ::locType::last
};

// xyType
//

xyType::
xyType ()
: ::xml_schema::type (),
  data_ (::xml_schema::flags (), this)
{
}

xyType::
xyType (const xyType& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  data_ (x.data_, f, this)
{
}

xyType::
xyType (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  data_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void xyType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // data
    //
    if (n.name () == "data" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< data_type > r (
        data_traits::create (i, f, this));

      this->data_.push_back (r);
      continue;
    }

    break;
  }
}

xyType* xyType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class xyType (*this, f, c);
}

xyType::
~xyType ()
{
}

// floatlist
//

floatlist::
floatlist (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::float_, char > (e, f, this)
{
}

floatlist::
floatlist (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::float_, char > (a, f, this)
{
}

floatlist::
floatlist (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::float_, char > (s, e, f, this)
{
}

floatlist* floatlist::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class floatlist (*this, f, c);
}

floatlist::
~floatlist ()
{
}

// integerlist
//

integerlist::
integerlist (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (e, f, this)
{
}

integerlist::
integerlist (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (a, f, this)
{
}

integerlist::
integerlist (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::int_, char > (s, e, f, this)
{
}

integerlist* integerlist::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class integerlist (*this, f, c);
}

integerlist::
~integerlist ()
{
}

// pType
//

pType::
pType ()
: ::xml_schema::type (),
  distribution_ (::xml_schema::flags (), this)
{
}

pType::
pType (const pType& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  distribution_ (x.distribution_, f, this)
{
}

pType::
pType (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  distribution_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void pType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // distribution
    //
    if (n.name () == "distribution" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< distribution_type > r (
        distribution_traits::create (i, f, this));

      this->distribution_.push_back (r);
      continue;
    }

    break;
  }
}

pType* pType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class pType (*this, f, c);
}

pType::
~pType ()
{
}

// data
//

data::
data (const type_type& type,
      const maxvalue_type& maxvalue,
      const file_type& file)
: ::xml_schema::type (),
  type_ (type, ::xml_schema::flags (), this),
  maxvalue_ (maxvalue, ::xml_schema::flags (), this),
  file_ (file, ::xml_schema::flags (), this),
  startgeneration_ (::xml_schema::flags (), this),
  endgeneration_ (::xml_schema::flags (), this)
{
}

data::
data (const data& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  maxvalue_ (x.maxvalue_, f, this),
  file_ (x.file_, f, this),
  startgeneration_ (x.startgeneration_, f, this),
  endgeneration_ (x.endgeneration_, f, this)
{
}

data::
data (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (f, this),
  maxvalue_ (f, this),
  file_ (f, this),
  startgeneration_ (f, this),
  endgeneration_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void data::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.set (r);
      continue;
    }

    if (n.name () == "maxvalue" && n.namespace_ ().empty ())
    {
      this->maxvalue_.set (maxvalue_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< file_type > r (
        file_traits::create (i, f, this));

      this->file_.set (r);
      continue;
    }

    if (n.name () == "startgeneration" && n.namespace_ ().empty ())
    {
      this->startgeneration_.set (startgeneration_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "endgeneration" && n.namespace_ ().empty ())
    {
      this->endgeneration_.set (endgeneration_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!maxvalue_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "maxvalue",
      "");
  }

  if (!file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "file",
      "");
  }
}

data* data::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class data (*this, f, c);
}

data::
~data ()
{
}

// distribution
//

distribution::
distribution (const p_type& p,
              const offspring_type& offspring)
: ::xml_schema::type (),
  p_ (p, ::xml_schema::flags (), this),
  offspring_ (offspring, ::xml_schema::flags (), this),
  startgeneration_ (::xml_schema::flags (), this),
  endgeneration_ (::xml_schema::flags (), this)
{
}

distribution::
distribution (const distribution& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  p_ (x.p_, f, this),
  offspring_ (x.offspring_, f, this),
  startgeneration_ (x.startgeneration_, f, this),
  endgeneration_ (x.endgeneration_, f, this)
{
}

distribution::
distribution (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  p_ (f, this),
  offspring_ (f, this),
  startgeneration_ (f, this),
  endgeneration_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void distribution::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "p" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< p_type > r (
        p_traits::create (i, f, this));

      this->p_.set (r);
      continue;
    }

    if (n.name () == "offspring" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< offspring_type > r (
        offspring_traits::create (i, f, this));

      this->offspring_.set (r);
      continue;
    }

    if (n.name () == "startgeneration" && n.namespace_ ().empty ())
    {
      this->startgeneration_.set (startgeneration_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "endgeneration" && n.namespace_ ().empty ())
    {
      this->endgeneration_.set (endgeneration_traits::create (i, f, this));
      continue;
    }
  }

  if (!p_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "p",
      "");
  }

  if (!offspring_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "offspring",
      "");
  }
}

distribution* distribution::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class distribution (*this, f, c);
}

distribution::
~distribution ()
{
}

// simulation
//

simulation::
simulation (const seed_type& seed,
            const generations_type& generations,
            const latitude_type& latitude,
            const longitude_type& longitude,
            const edges_type& edges,
            const carryingcapacity_type& carryingcapacity,
            const hardborders_type& hardborders,
            const softborders_type& softborders,
            const reproductiveability_type& reproductiveability,
            const dispersalradius_type& dispersalradius,
            const loci_type& loci,
            const initialpopulation_type& initialpopulation,
            const output_type& output,
            const name_type& name)
: ::xml_schema::type (),
  seed_ (seed, ::xml_schema::flags (), this),
  generations_ (generations, ::xml_schema::flags (), this),
  latitude_ (latitude, ::xml_schema::flags (), this),
  longitude_ (longitude, ::xml_schema::flags (), this),
  edges_ (edges, ::xml_schema::flags (), this),
  carryingcapacity_ (carryingcapacity, ::xml_schema::flags (), this),
  hardborders_ (hardborders, ::xml_schema::flags (), this),
  softborders_ (softborders, ::xml_schema::flags (), this),
  reproductiveability_ (reproductiveability, ::xml_schema::flags (), this),
  dispersalradius_ (dispersalradius, ::xml_schema::flags (), this),
  loci_ (loci, ::xml_schema::flags (), this),
  initialpopulation_ (initialpopulation, ::xml_schema::flags (), this),
  output_ (output, ::xml_schema::flags (), this),
  name_ (name, ::xml_schema::flags (), this)
{
}

simulation::
simulation (const seed_type& seed,
            const generations_type& generations,
            ::std::auto_ptr< latitude_type >& latitude,
            ::std::auto_ptr< longitude_type >& longitude,
            ::std::auto_ptr< edges_type >& edges,
            ::std::auto_ptr< carryingcapacity_type >& carryingcapacity,
            ::std::auto_ptr< hardborders_type >& hardborders,
            ::std::auto_ptr< softborders_type >& softborders,
            ::std::auto_ptr< reproductiveability_type >& reproductiveability,
            ::std::auto_ptr< dispersalradius_type >& dispersalradius,
            ::std::auto_ptr< loci_type >& loci,
            ::std::auto_ptr< initialpopulation_type >& initialpopulation,
            ::std::auto_ptr< output_type >& output,
            const name_type& name)
: ::xml_schema::type (),
  seed_ (seed, ::xml_schema::flags (), this),
  generations_ (generations, ::xml_schema::flags (), this),
  latitude_ (latitude, ::xml_schema::flags (), this),
  longitude_ (longitude, ::xml_schema::flags (), this),
  edges_ (edges, ::xml_schema::flags (), this),
  carryingcapacity_ (carryingcapacity, ::xml_schema::flags (), this),
  hardborders_ (hardborders, ::xml_schema::flags (), this),
  softborders_ (softborders, ::xml_schema::flags (), this),
  reproductiveability_ (reproductiveability, ::xml_schema::flags (), this),
  dispersalradius_ (dispersalradius, ::xml_schema::flags (), this),
  loci_ (loci, ::xml_schema::flags (), this),
  initialpopulation_ (initialpopulation, ::xml_schema::flags (), this),
  output_ (output, ::xml_schema::flags (), this),
  name_ (name, ::xml_schema::flags (), this)
{
}

simulation::
simulation (const simulation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  seed_ (x.seed_, f, this),
  generations_ (x.generations_, f, this),
  latitude_ (x.latitude_, f, this),
  longitude_ (x.longitude_, f, this),
  edges_ (x.edges_, f, this),
  carryingcapacity_ (x.carryingcapacity_, f, this),
  hardborders_ (x.hardborders_, f, this),
  softborders_ (x.softborders_, f, this),
  reproductiveability_ (x.reproductiveability_, f, this),
  dispersalradius_ (x.dispersalradius_, f, this),
  loci_ (x.loci_, f, this),
  initialpopulation_ (x.initialpopulation_, f, this),
  output_ (x.output_, f, this),
  name_ (x.name_, f, this)
{
}

simulation::
simulation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  seed_ (f, this),
  generations_ (f, this),
  latitude_ (f, this),
  longitude_ (f, this),
  edges_ (f, this),
  carryingcapacity_ (f, this),
  hardborders_ (f, this),
  softborders_ (f, this),
  reproductiveability_ (f, this),
  dispersalradius_ (f, this),
  loci_ (f, this),
  initialpopulation_ (f, this),
  output_ (f, this),
  name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void simulation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // seed
    //
    if (n.name () == "seed" && n.namespace_ ().empty ())
    {
      if (!seed_.present ())
      {
        this->seed_.set (seed_traits::create (i, f, this));
        continue;
      }
    }

    // generations
    //
    if (n.name () == "generations" && n.namespace_ ().empty ())
    {
      if (!generations_.present ())
      {
        this->generations_.set (generations_traits::create (i, f, this));
        continue;
      }
    }

    // latitude
    //
    if (n.name () == "latitude" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< latitude_type > r (
        latitude_traits::create (i, f, this));

      if (!latitude_.present ())
      {
        this->latitude_.set (r);
        continue;
      }
    }

    // longitude
    //
    if (n.name () == "longitude" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< longitude_type > r (
        longitude_traits::create (i, f, this));

      if (!longitude_.present ())
      {
        this->longitude_.set (r);
        continue;
      }
    }

    // edges
    //
    if (n.name () == "edges" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< edges_type > r (
        edges_traits::create (i, f, this));

      if (!edges_.present ())
      {
        this->edges_.set (r);
        continue;
      }
    }

    // carryingcapacity
    //
    if (n.name () == "carryingcapacity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< carryingcapacity_type > r (
        carryingcapacity_traits::create (i, f, this));

      if (!carryingcapacity_.present ())
      {
        this->carryingcapacity_.set (r);
        continue;
      }
    }

    // hardborders
    //
    if (n.name () == "hardborders" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< hardborders_type > r (
        hardborders_traits::create (i, f, this));

      if (!hardborders_.present ())
      {
        this->hardborders_.set (r);
        continue;
      }
    }

    // softborders
    //
    if (n.name () == "softborders" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< softborders_type > r (
        softborders_traits::create (i, f, this));

      if (!softborders_.present ())
      {
        this->softborders_.set (r);
        continue;
      }
    }

    // reproductiveability
    //
    if (n.name () == "reproductiveability" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< reproductiveability_type > r (
        reproductiveability_traits::create (i, f, this));

      if (!reproductiveability_.present ())
      {
        this->reproductiveability_.set (r);
        continue;
      }
    }

    // dispersalradius
    //
    if (n.name () == "dispersalradius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dispersalradius_type > r (
        dispersalradius_traits::create (i, f, this));

      if (!dispersalradius_.present ())
      {
        this->dispersalradius_.set (r);
        continue;
      }
    }

    // loci
    //
    if (n.name () == "loci" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< loci_type > r (
        loci_traits::create (i, f, this));

      if (!loci_.present ())
      {
        this->loci_.set (r);
        continue;
      }
    }

    // initialpopulation
    //
    if (n.name () == "initialpopulation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< initialpopulation_type > r (
        initialpopulation_traits::create (i, f, this));

      if (!initialpopulation_.present ())
      {
        this->initialpopulation_.set (r);
        continue;
      }
    }

    // output
    //
    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< output_type > r (
        output_traits::create (i, f, this));

      if (!output_.present ())
      {
        this->output_.set (r);
        continue;
      }
    }

    break;
  }

  if (!seed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "seed",
      "");
  }

  if (!generations_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "generations",
      "");
  }

  if (!latitude_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "latitude",
      "");
  }

  if (!longitude_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "longitude",
      "");
  }

  if (!edges_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "edges",
      "");
  }

  if (!carryingcapacity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "carryingcapacity",
      "");
  }

  if (!hardborders_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "hardborders",
      "");
  }

  if (!softborders_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "softborders",
      "");
  }

  if (!reproductiveability_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "reproductiveability",
      "");
  }

  if (!dispersalradius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dispersalradius",
      "");
  }

  if (!loci_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "loci",
      "");
  }

  if (!initialpopulation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initialpopulation",
      "");
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name_.set (r);
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

simulation* simulation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation (*this, f, c);
}

simulation::
~simulation ()
{
}

// latitude
//

latitude::
latitude (const minimum_type& minimum,
          const maximum_type& maximum)
: ::xml_schema::type (),
  minimum_ (minimum, ::xml_schema::flags (), this),
  maximum_ (maximum, ::xml_schema::flags (), this)
{
}

latitude::
latitude (const latitude& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  minimum_ (x.minimum_, f, this),
  maximum_ (x.maximum_, f, this)
{
}

latitude::
latitude (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  minimum_ (f, this),
  maximum_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void latitude::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "minimum" && n.namespace_ ().empty ())
    {
      this->minimum_.set (minimum_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "maximum" && n.namespace_ ().empty ())
    {
      this->maximum_.set (maximum_traits::create (i, f, this));
      continue;
    }
  }

  if (!minimum_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "minimum",
      "");
  }

  if (!maximum_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "maximum",
      "");
  }
}

latitude* latitude::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class latitude (*this, f, c);
}

latitude::
~latitude ()
{
}

// longitude
//

longitude::
longitude (const minimum_type& minimum,
           const maximum_type& maximum)
: ::xml_schema::type (),
  minimum_ (minimum, ::xml_schema::flags (), this),
  maximum_ (maximum, ::xml_schema::flags (), this)
{
}

longitude::
longitude (const longitude& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  minimum_ (x.minimum_, f, this),
  maximum_ (x.maximum_, f, this)
{
}

longitude::
longitude (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  minimum_ (f, this),
  maximum_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void longitude::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "minimum" && n.namespace_ ().empty ())
    {
      this->minimum_.set (minimum_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "maximum" && n.namespace_ ().empty ())
    {
      this->maximum_.set (maximum_traits::create (i, f, this));
      continue;
    }
  }

  if (!minimum_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "minimum",
      "");
  }

  if (!maximum_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "maximum",
      "");
  }
}

longitude* longitude::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class longitude (*this, f, c);
}

longitude::
~longitude ()
{
}

// edges
//

edges::
edges (const type_type& type)
: ::xml_schema::type (),
  type_ (type, ::xml_schema::flags (), this)
{
}

edges::
edges (const edges& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this)
{
}

edges::
edges (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void edges::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.set (r);
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

edges* edges::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class edges (*this, f, c);
}

edges::
~edges ()
{
}

// loci
//

loci::
loci (const numloci_type& numloci,
      const recombinationrate_type& recombinationrate)
: ::xml_schema::type (),
  numloci_ (numloci, ::xml_schema::flags (), this),
  recombinationrate_ (recombinationrate, ::xml_schema::flags (), this)
{
}

loci::
loci (const loci& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  numloci_ (x.numloci_, f, this),
  recombinationrate_ (x.recombinationrate_, f, this)
{
}

loci::
loci (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  numloci_ (f, this),
  recombinationrate_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void loci::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "numloci" && n.namespace_ ().empty ())
    {
      this->numloci_.set (numloci_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "recombinationrate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< recombinationrate_type > r (
        recombinationrate_traits::create (i, f, this));

      this->recombinationrate_.set (r);
      continue;
    }
  }

  if (!numloci_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "numloci",
      "");
  }

  if (!recombinationrate_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "recombinationrate",
      "");
  }
}

loci* loci::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class loci (*this, f, c);
}

loci::
~loci ()
{
}

// initialpopulation
//

initialpopulation::
initialpopulation ()
: ::xml_schema::type (),
  node_ (::xml_schema::flags (), this)
{
}

initialpopulation::
initialpopulation (const initialpopulation& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  node_ (x.node_, f, this)
{
}

initialpopulation::
initialpopulation (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  node_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void initialpopulation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // node
    //
    if (n.name () == "node" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< node_type > r (
        node_traits::create (i, f, this));

      this->node_.push_back (r);
      continue;
    }

    break;
  }
}

initialpopulation* initialpopulation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class initialpopulation (*this, f, c);
}

initialpopulation::
~initialpopulation ()
{
}

// output
//

output::
output ()
: ::xml_schema::type (),
  visual_ (::xml_schema::flags (), this),
  treestructure_ (::xml_schema::flags (), this),
  locations_ (::xml_schema::flags (), this),
  ndna_ (::xml_schema::flags (), this)
{
}

output::
output (const output& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  visual_ (x.visual_, f, this),
  treestructure_ (x.treestructure_, f, this),
  locations_ (x.locations_, f, this),
  ndna_ (x.ndna_, f, this)
{
}

output::
output (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  visual_ (f, this),
  treestructure_ (f, this),
  locations_ (f, this),
  ndna_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void output::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // visual
    //
    if (n.name () == "visual" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< visual_type > r (
        visual_traits::create (i, f, this));

      if (!this->visual_)
      {
        this->visual_.set (r);
        continue;
      }
    }

    // treestructure
    //
    if (n.name () == "treestructure" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< treestructure_type > r (
        treestructure_traits::create (i, f, this));

      this->treestructure_.push_back (r);
      continue;
    }

    // locations
    //
    if (n.name () == "locations" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< locations_type > r (
        locations_traits::create (i, f, this));

      this->locations_.push_back (r);
      continue;
    }

    // ndna
    //
    if (n.name () == "ndna" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ndna_type > r (
        ndna_traits::create (i, f, this));

      this->ndna_.push_back (r);
      continue;
    }

    break;
  }
}

output* output::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class output (*this, f, c);
}

output::
~output ()
{
}

// node
//

node::
node (const lat_type& lat,
      const lon_type& lon,
      const n_type& n,
      const r_type& r,
      const g_type& g,
      const b_type& b,
      const sex_type& sex,
      const mloci_type& mloci,
      const floci_type& floci)
: ::xml_schema::type (),
  lat_ (lat, ::xml_schema::flags (), this),
  lon_ (lon, ::xml_schema::flags (), this),
  n_ (n, ::xml_schema::flags (), this),
  r_ (r, ::xml_schema::flags (), this),
  g_ (g, ::xml_schema::flags (), this),
  b_ (b, ::xml_schema::flags (), this),
  sex_ (sex, ::xml_schema::flags (), this),
  mloci_ (mloci, ::xml_schema::flags (), this),
  floci_ (floci, ::xml_schema::flags (), this)
{
}

node::
node (const node& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lat_ (x.lat_, f, this),
  lon_ (x.lon_, f, this),
  n_ (x.n_, f, this),
  r_ (x.r_, f, this),
  g_ (x.g_, f, this),
  b_ (x.b_, f, this),
  sex_ (x.sex_, f, this),
  mloci_ (x.mloci_, f, this),
  floci_ (x.floci_, f, this)
{
}

node::
node (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lat_ (f, this),
  lon_ (f, this),
  n_ (f, this),
  r_ (f, this),
  g_ (f, this),
  b_ (f, this),
  sex_ (f, this),
  mloci_ (f, this),
  floci_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void node::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "lat" && n.namespace_ ().empty ())
    {
      this->lat_.set (lat_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lon" && n.namespace_ ().empty ())
    {
      this->lon_.set (lon_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "n" && n.namespace_ ().empty ())
    {
      this->n_.set (n_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "r" && n.namespace_ ().empty ())
    {
      this->r_.set (r_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "g" && n.namespace_ ().empty ())
    {
      this->g_.set (g_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "b" && n.namespace_ ().empty ())
    {
      this->b_.set (b_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< sex_type > r (
        sex_traits::create (i, f, this));

      this->sex_.set (r);
      continue;
    }

    if (n.name () == "mloci" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mloci_type > r (
        mloci_traits::create (i, f, this));

      this->mloci_.set (r);
      continue;
    }

    if (n.name () == "floci" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< floci_type > r (
        floci_traits::create (i, f, this));

      this->floci_.set (r);
      continue;
    }
  }

  if (!lat_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "lat",
      "");
  }

  if (!lon_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "lon",
      "");
  }

  if (!n_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "n",
      "");
  }

  if (!r_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "r",
      "");
  }

  if (!g_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "g",
      "");
  }

  if (!b_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "b",
      "");
  }

  if (!sex_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sex",
      "");
  }

  if (!mloci_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mloci",
      "");
  }

  if (!floci_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "floci",
      "");
  }
}

node* node::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class node (*this, f, c);
}

node::
~node ()
{
}

// visual
//

visual::
visual (const output_every_type& output_every)
: ::xml_schema::type (),
  output_every_ (output_every, ::xml_schema::flags (), this),
  xsize_ (::xml_schema::flags (), this),
  ysize_ (::xml_schema::flags (), this)
{
}

visual::
visual (const visual& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  output_every_ (x.output_every_, f, this),
  xsize_ (x.xsize_, f, this),
  ysize_ (x.ysize_, f, this)
{
}

visual::
visual (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  output_every_ (f, this),
  xsize_ (f, this),
  ysize_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void visual::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "output_every" && n.namespace_ ().empty ())
    {
      this->output_every_.set (output_every_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "xsize" && n.namespace_ ().empty ())
    {
      this->xsize_.set (xsize_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ysize" && n.namespace_ ().empty ())
    {
      this->ysize_.set (ysize_traits::create (i, f, this));
      continue;
    }
  }

  if (!output_every_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_every",
      "");
  }
}

visual* visual::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class visual (*this, f, c);
}

visual::
~visual ()
{
}

// treestructure
//

treestructure::
treestructure (const output_type& output,
               const file_type& file,
               const output_every_type& output_every)
: ::xml_schema::type (),
  delimeter_ (::xml_schema::flags (), this),
  output_ (output, ::xml_schema::flags (), this),
  file_ (file, ::xml_schema::flags (), this),
  trim_ (::xml_schema::flags (), this),
  resolve_ (::xml_schema::flags (), this),
  mutationrate_ (::xml_schema::flags (), this),
  output_every_ (output_every, ::xml_schema::flags (), this)
{
}

treestructure::
treestructure (const treestructure& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  delimeter_ (x.delimeter_, f, this),
  output_ (x.output_, f, this),
  file_ (x.file_, f, this),
  trim_ (x.trim_, f, this),
  resolve_ (x.resolve_, f, this),
  mutationrate_ (x.mutationrate_, f, this),
  output_every_ (x.output_every_, f, this)
{
}

treestructure::
treestructure (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  delimeter_ (f, this),
  output_ (f, this),
  file_ (f, this),
  trim_ (f, this),
  resolve_ (f, this),
  mutationrate_ (f, this),
  output_every_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void treestructure::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "delimeter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< delimeter_type > r (
        delimeter_traits::create (i, f, this));

      this->delimeter_.set (r);
      continue;
    }

    if (n.name () == "output" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< output_type > r (
        output_traits::create (i, f, this));

      this->output_.set (r);
      continue;
    }

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< file_type > r (
        file_traits::create (i, f, this));

      this->file_.set (r);
      continue;
    }

    if (n.name () == "trim" && n.namespace_ ().empty ())
    {
      this->trim_.set (trim_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "resolve" && n.namespace_ ().empty ())
    {
      this->resolve_.set (resolve_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mutationrate" && n.namespace_ ().empty ())
    {
      this->mutationrate_.set (mutationrate_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output_every" && n.namespace_ ().empty ())
    {
      this->output_every_.set (output_every_traits::create (i, f, this));
      continue;
    }
  }

  if (!output_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output",
      "");
  }

  if (!file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "file",
      "");
  }

  if (!output_every_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_every",
      "");
  }
}

treestructure* treestructure::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class treestructure (*this, f, c);
}

treestructure::
~treestructure ()
{
}

// locations
//

locations::
locations (const generation_type& generation,
           const file_type& file,
           const output_every_type& output_every)
: ::xml_schema::type (),
  generation_ (generation, ::xml_schema::flags (), this),
  file_ (file, ::xml_schema::flags (), this),
  output_every_ (output_every, ::xml_schema::flags (), this)
{
}

locations::
locations (const locations& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  generation_ (x.generation_, f, this),
  file_ (x.file_, f, this),
  output_every_ (x.output_every_, f, this)
{
}

locations::
locations (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  generation_ (f, this),
  file_ (f, this),
  output_every_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void locations::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "generation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< generation_type > r (
        generation_traits::create (i, f, this));

      this->generation_.set (r);
      continue;
    }

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< file_type > r (
        file_traits::create (i, f, this));

      this->file_.set (r);
      continue;
    }

    if (n.name () == "output_every" && n.namespace_ ().empty ())
    {
      this->output_every_.set (output_every_traits::create (i, f, this));
      continue;
    }
  }

  if (!generation_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "generation",
      "");
  }

  if (!file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "file",
      "");
  }

  if (!output_every_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_every",
      "");
  }
}

locations* locations::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class locations (*this, f, c);
}

locations::
~locations ()
{
}

// ndna
//

ndna::
ndna (const file_type& file,
      const output_every_type& output_every)
: ::xml_schema::type (),
  delimeter_ (::xml_schema::flags (), this),
  file_ (file, ::xml_schema::flags (), this),
  trim_ (::xml_schema::flags (), this),
  output_every_ (output_every, ::xml_schema::flags (), this)
{
}

ndna::
ndna (const ndna& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  delimeter_ (x.delimeter_, f, this),
  file_ (x.file_, f, this),
  trim_ (x.trim_, f, this),
  output_every_ (x.output_every_, f, this)
{
}

ndna::
ndna (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  delimeter_ (f, this),
  file_ (f, this),
  trim_ (f, this),
  output_every_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ndna::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "delimeter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< delimeter_type > r (
        delimeter_traits::create (i, f, this));

      this->delimeter_.set (r);
      continue;
    }

    if (n.name () == "file" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< file_type > r (
        file_traits::create (i, f, this));

      this->file_.set (r);
      continue;
    }

    if (n.name () == "trim" && n.namespace_ ().empty ())
    {
      this->trim_.set (trim_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output_every" && n.namespace_ ().empty ())
    {
      this->output_every_.set (output_every_traits::create (i, f, this));
      continue;
    }
  }

  if (!file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "file",
      "");
  }

  if (!output_every_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_every",
      "");
  }
}

ndna* ndna::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ndna (*this, f, c);
}

ndna::
~ndna ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::simulation > r (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::simulation > r (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulation >
simulation_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::simulation > r (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulation_ (isrc, h, f, p);
}

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::simulation > r (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::simulation > r (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulation >
simulation_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::simulation > r (
    ::simulation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::simulation >
simulation_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::simulation > r (
      ::simulation_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulation > r (
      ::xsd::cxx::tree::traits< ::simulation, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

::std::auto_ptr< ::simulation >
simulation_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulation" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulation > r (
      ::xsd::cxx::tree::traits< ::simulation, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulation",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

